/* Carlos_Augusto_Lima_Mattoso 1210553 */

INTRODUÇÃO
==========
  O trabalho foi testado através de uma sequência de testes 
manuais para cada uma das funções pedidas. Uma função big_dump
foi feita para avaliar se os resultados estavam corretos.
  O programa de testes recebia dois números, e realizava uma 
série de operações sobre eles para verificar se tudo dava certo.

1) big_val && big_uval
======================
  Valores testados -- ambas 
  -------------------------
    -1, 1, 2, -2, 3, 255, 2147483647, -2147483648

    Os números foram gerados com os valores esperados. No caso
  dos negativos, o sinal foi replicado como esperado.

2) big_sum && big_sub
=====================
  Valores testados - big_sum
  --------------------------
    (-1 + 1)  ->   0, teste de overflow, ok!
    (-1 + 2)  ->   1, teste de overflow, ok!
    (2 + 3)   ->   5, ok!
    (-1 + -1) ->  -2, teste de soma de negativos, ok!
    (255 + 1) -> 256, ok!
 
  Valores testados - big_sum
  --------------------------
    Para o caso da big_sub, o mesmo foi feito. A big_sub é
  simplesmente a soma do primeiro número com o inverso do
  segundo. Criou-se uma função auxiliar para negativar o
  segundo número.

    (-1 - -1) ->  0, teste de inversão de negativo, ok!
    (-1 -  1) -> -2, ok!
    (-1 -  2) -> -3, teste de inversão de positivos, ok!
    (2  -  3) -> -1, ok
    (2147483647 - -2147483648) -> 4294967295, ok!


 3) big_mul & big_umul
 =====================
    O algoritmo implementado segue o algoritmo tradicional de 
  multiplicação, shiftando o a para a esquerda, e somando-o à
  resposta sempre que se encontrar um 1 no b. O processo de 
  shifts foi otimizado, só ocorrendo todos os shifts necessários
  ao encontrarmos um 1 em b.
    O algoritmo de big_umul, também funciona para valores signed.
    
  Valores testados (os negativos para caso signed)
  ------------------------------------------------
    (-1 * -1) ->  1, ok!
    (-1 * -2) ->  2, ok!
    (-1 *  2) -> -2, ok! 

  # big_mul ou big_umul abaixo
    (3  *  2) ->  6, ok!
    (2147483647 * 2) -> 4294967294, ok!

 4) big_cmp & big_ucmp
 =====================
  Valores testados -- big_cmp
  ---------------------------
    (-1  cmp -1) -> ==, ok!
    (-1  cmp -2) ->  >, ok!
    (-2  cmp -1) ->  <, ok!
    (-1  cmp  2) ->  <, ok!
    (2   cmp  3) ->  <, ok!
    (2   cmp  2) -> ==, ok!
    (2147483647 cmp 2147483647) -> ==, ok
  
  Valores testados -- big_ucmp
  ----------------------------
    (-1 ucmp  2) ->   >, ok!
    (-1 ucmp -1) ->  ==, ok!
    (2  ucmp -1) ->   <, ok!

    (3  ucmp  2) ->   >, ok!
    (2  ucmp  2) ->  ==, ok!
    (2  ucmp  3) ->   <, ok!
        

 5) big_shl & big_shr
 ====================
  Valores testados -- big_shl
  ---------------------------
    (16 shl 0)    -> 16, ok! -- caso limite
    (16 shl 128)  ->  0, ok! -- caso limite
    (16 shl 5813) ->  0, ok! -- caso limite
    (16 shl 2)    -> 64, ok!

    (-1 shl 1)    -> -2, ok! -- teste de negativo

  Valores testados -- big_shl
  ---------------------------
    (16 shr 0)    -> 16, ok! -- caso limite
    (16 shr 128)  ->  0, ok! -- caso limite
    (16 shr 5813) ->  0, ok! -- caso limite
    (16 shr 2)    ->  4, ok!

    (-1 shr 1)    -> 0x7f no byte mais 
                     significativo, ok!




